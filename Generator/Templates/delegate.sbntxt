using System;
using System.Runtime.InteropServices;

{{~
$managed_name = get_metadata "ManagedName"
~}}

namespace {{ namespace.name }}
{
    // AUTOGENERATED FILE - DO NOT MODIFY

    public delegate {{ return_value | write_managed_return_value }} {{ $managed_name }}({{ parameter_list | write_managed_arguments}});

    public delegate {{ return_value | write_native_return_value }} {{ symbol_name }}({{ parameter_list | write_native_arguments}});
    
    /// <summary>
    /// Call Handler for {{ $managed_name }}. A call annotation indicates the closure should
    /// be valid for the duration of the call. This handler does not implement any special
    /// memory management. 
    /// </summary>
    public class {{ $managed_name }}CallHandler : IDisposable
    {
        public {{ symbol_name }} NativeCallback;

        private {{ $managed_name }} managedCallback;
    
        public {{ $managed_name }}CallHandler({{ $managed_name }} managed)
        {
            NativeCallback = default; //TODO: NativeCallbackMarshaller;
            managedCallback = managed;
        }
        /* TODO
        private {{ return_value | write_managed_return_value }} NativeCallbackMarshaller({{ parameter_list | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' }}
            
            {{~ if return_value | return_value_is_void != true ~}}
            return default; //managed_callback_result;
            {{~ end ~}}
        }
        */
        
        public void Dispose()
        {
            // This implements IDisposable just to signal to the caller that this class contains
            // disposable state. Actually there is no state which needs to be freed. But if an instance
            // of this object is freed to early the NativeCallback can not be invoked from C anymore
            // which breaks any native code relying on the availability of the NativeCallback.
        }
    }
    
    /// <summary>
    /// Async Handler for {{ $managed_name }}. An async annotation indicates the closure will
    /// be called precisely once, after which it is then available for garbage collection.
    /// </summary>
    public class {{ $managed_name }}AsyncHandler : IDisposable
    {
        public {{ symbol_name }} NativeCallback;

        private {{ $managed_name }} managedCallback;
        private GCHandle gch;
    
        public {{ $managed_name }}AsyncHandler({{ $managed_name }} managed)
        {
            NativeCallback = default; //TODO: NativeCallbackMarshaller;
            managedCallback = managed;
            gch = GCHandle.Alloc(this);
        }
    
        /* TODO
        private {{ return_value | write_managed_return_value }} NativeCallbackMarshaller({{ parameter_list | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' }}
            
            // Async callbacks are only ever called once
            gch.Free();
            
            {{~ if return_value | return_value_is_void != true ~}}
            return default; //TODO: managed_callback_result;
            {{~ end ~}}
        }
        */
        
        public void Dispose()
        {
            if(gch.IsAllocated)
                gch.Free();
        }
    }

    /// <summary>
    /// Notified Handler for {{ $managed_name }}. A notified annotation indicates the closure should
    /// be kept alive until it is manually removed by the user. This removal is indicated by a
    /// destroy_notify event, emitted by the relevant library. Pass <c>DestroyNotify</c> in place of a
    /// destroy_notify callback parameter. 
    /// </summary>
    public class {{ $managed_name }}NotifiedHandler : IDisposable
    {
        public event System.Action OnDestroyNotify;
        public {{ symbol_name }} NativeCallback;
        public GLib.DestroyNotifyCallback DestroyNotify;

        private {{ $managed_name }} managedCallback;
        private GCHandle gch;

        public {{ $managed_name }}NotifiedHandler({{ $managed_name }} managed)
        {
            DestroyNotify = DestroyCallback;
            NativeCallback = default; //TODO: NativeCallbackMarshaller;
            managedCallback = managed;
            gch = GCHandle.Alloc(this);
        }

        /* TODO
        private {{ return_value | write_managed_return_value }} NativeCallbackMarshaller({{ parameter_list | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' }}
            
            {{~ if return_value | return_value_is_void != true ~}}
            return default; //TODO: managed_callback_result;
            {{~ end ~}}
        }
        */

        private void DestroyCallback(IntPtr userData)
        {
            OnDestroyNotify();

            // Allow for garbage collection
            gch.Free();
        }
        
        public void Dispose()
        {
            if(gch.IsAllocated)
                gch.Free();
        }
    }
}
