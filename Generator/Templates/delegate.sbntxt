{{~
wrapper_name = get_metadata "WrapperName"
~}}

using System;
using System.Runtime.InteropServices;

namespace {{ namespace.name }}
{
    // AUTOGENERATED FILE - DO NOT MODIFY

    public delegate {{ return_value.symbol_reference | write_managed_symbol_reference }} {{ wrapper_name }}({{ arguments | write_managed_arguments}});

    public delegate {{ return_value.symbol_reference | write_native_symbol_reference }} {{ managed_name }}({{ arguments | write_native_arguments}});
    
    /// <summary>
    /// Call Handler for {{ wrapper_name }}. A call annotation indicates the closure should
    /// be valid for the duration of the call. This handler does not implement any special
    /// memory management. 
    /// </summary>
    public class {{ wrapper_name }}CallHandler
    {
        public {{ managed_name }} NativeCallback;

        private {{ wrapper_name }} managedCallback;
    
        public {{ wrapper_name }}CallHandler({{ wrapper_name }} managed)
        {
            NativeCallback = NativeCallbackMarshaller;
            managedCallback = managed;
        }
    
        private {{ return_value.symbol_reference | write_managed_symbol_reference }} NativeCallbackMarshaller({{ arguments | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' arguments "managedCallback" (return_value != null) }}
            
            {{~ if return_value ~}} 
            return result;
            {{~ end ~}}
        }
    }
    
    /// <summary>
    /// Async Handler for {{ wrapper_name }}. An async annotation indicates the closure will
    /// be called precisely once, after which it is then available for garbage collection.
    /// </summary>
    public class {{ wrapper_name }}AsyncHandler
    {
        public {{ managed_name }} NativeCallback;

        private {{ wrapper_name }} managedCallback;
        private GCHandle gch;
    
        public {{ wrapper_name }}AsyncHandler({{ wrapper_name }} managed)
        {
            NativeCallback = NativeCallbackMarshaller;
            managedCallback = managed;
            gch = GCHandle.Alloc(this);
        }
    
        private {{ return_value.symbol_reference | write_managed_symbol_reference }} NativeCallbackMarshaller({{ arguments | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' arguments "managedCallback" (return_value != null) }}
            
            // Async callbacks are only ever called once
            gch.Free();
            
            {{~ if return_value ~}} 
            return result;
            {{~ end ~}}
        }
    }

    /// <summary>
    /// Notified Handler for {{ wrapper_name }}. A notified annotation indicates the closure should
    /// be kept alive until it is manually removed by the user. This removal is indicated by a
    /// destroy_notify event, emitted by the relevant library. Pass <c>DestroyNotify</c> in place of a
    /// destroy_notify callback parameter. 
    /// </summary>
    public class {{ wrapper_name }}NotifiedHandler
    {
        public event Action OnDestroyNotify;
        public {{ managed_name }} NativeCallback;
        public DestroyNotifyNative DestroyNotify;

        private {{ wrapper_name }} managedCallback;
        private GCHandle gch;

        public {{ wrapper_name }}NotifiedHandler({{ wrapper_name }} managed)
        {
            DestroyNotify = DestroyCallback;
            NativeCallback = NativeCallbackMarshaller;
            managedCallback = managed;
            gch = GCHandle.Alloc(this);
        }

        private {{ return_value.symbol_reference | write_managed_symbol_reference }} NativeCallbackMarshaller({{ arguments | write_native_arguments}})
        {
            {{ include 'delegate.marshaller.sbntxt' arguments "managedCallback" (return_value != null) }}
            
            {{~ if return_value ~}} 
            return result;
            {{~ end ~}}
        }

        private void DestroyCallback(IntPtr? userData)
        {
            OnDestroyNotify();

            // Allow for garbage collection
            gch.Free();
        }
    }
}
