using System.Collections.Generic;
using Generator3.Renderer.Internal;

namespace Generator3.Generation.Callback
{
    public class PublicHandlerTemplate : Template<PublicHandlerModel>
    {
        public string Render(PublicHandlerModel model)
        {
            return $@"
using System;
using System.Runtime.InteropServices;

#nullable enable

namespace { model.NamespaceName }
{{
    // AUTOGENERATED FILE - DO NOT MODIFY

    // <summary>
    /// Call Handler for {model.DelegateType}. A call annotation indicates the closure should
    /// be valid for the duration of the call. This handler does not implement any special
    /// memory management. 
    /// </summary>
    public class {model.Name} : IDisposable
    {{
        private {model.DelegateType}  managedCallback;

        public {model.InternalDelegateType} NativeCallback;
    
        public {model.Name}({model.DelegateType} managed)
        {{
            managedCallback = managed;
            NativeCallback = ({model.InternalParameters.Render()}) => {{
                // Convert from native to managed
                

                // Call managedCallback

                // Return convert managed to native
                // TODO: Return Value
                {(!model.InternalReturnType.IsVoid() ? "return default!;" : string.Empty)}
            }};
        }}
        
        public void Dispose()
        {{
            // This implements IDisposable just to signal to the caller that this class contains
            // disposable state. Actually there is no state which needs to be freed. But if an instance
            // of this object is freed to early the NativeCallback can not be invoked from C anymore
            // which breaks any native code relying on the availability of the NativeCallback.
        }}
    }}
}}";
        }
    }
}
