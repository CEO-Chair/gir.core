using Generator.Model;

namespace Generator.Renderer.Public;

internal static class CallbackHandler
{
    public static string Render(GirModel.Callback callback)
    {
        var handlerName = callback.Name + "Handler";

        return $@"
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Runtime.Versioning;

#nullable enable

namespace {Namespace.GetPublicName(callback.Namespace)}
{{
    // AUTOGENERATED FILE - DO NOT MODIFY

    // <summary>
    /// Call Handler for {callback.Name}. A call annotation indicates the closure should
    /// be valid for the duration of the call. This handler does not implement any special
    /// memory management. 
    /// </summary>
    {PlatformSupportAttribute.Render(callback as GirModel.PlatformDependent)}
    public class {handlerName} : IDisposable
    {{
        private {callback.Name}  managedCallback;

        public {Namespace.GetInternalName(callback.Namespace)}.{callback.Name} NativeCallback;
    
        public {handlerName}({callback.Name} managed)
        {{
            managedCallback = managed;
            {CallbackCommonHandlerRenderUtils.RenderNativeCallback(callback)}
        }}
        
        public void Dispose()
        {{
            // This implements IDisposable just to signal to the caller that this class contains
            // disposable state. Actually there is no state which needs to be freed. But if an instance
            // of this object is freed to early the NativeCallback can not be invoked from C anymore
            // which breaks any native code relying on the availability of the NativeCallback.
        }}
    }}
}}";
    }
}
